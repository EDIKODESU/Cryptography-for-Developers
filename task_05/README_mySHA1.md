# Програмна реалізація алгоритму гешування SHA1
Цей проект містить завдання та приклад коду для тестування ключів відповідно до стандарта FIPS-140. 

## Загальні відомості про завдання
  Для виконання практичного завдання вам треба дослідити специфікацію алгоритму гешування використовуючи будь-яке зручне джерело інформації. Наступним кроком треба обрати зручну мову програмування та програмно реалізувати алгоритм гешування. Зверніть увагу на тип даних, що приймає ваша геш-функція.
  Важливо щоб ваша реалізація могла приймати будь-які дані в якості аргументу, тобто гешувати як текстові дані, так і серіалізовані структури, а також дані з бінарних файлів. Отже геш-функція має приймати масив байтів довільної довжини.
  Ваша функція гешування має повертати геш-значення у вигляді масиву байтів, який одразу можна використовувати в структурах даних, записати в бінарний файл, виконати порівняння з іншим геш-значенням тощо. Лише для зручності сприйняття геш-значення людиною його можна закодувати в шістнадцяткову систему числення і вивести на екран. Решту інших процесів з геш-значенням варто виконувати зберігаючи його у масиві байтів.
  Тестування вашої функції на коректність обчислень, оптимізація перетворень і перевірка швидкодії є важливим етапом реалізації криптографічного алгоритму.
  В репозиторій з вихідним кодом вашої реалізації алгоритму додайте readme.md файл з описом програми, інструкціями щодо запуску, прикладом виклику і поверненим результатом. Дані перевірки швидкодії і результати порівняння часу гешування з бібліотечною реалізацією також додайте до вашого репозиторію.

## 2.1 Власна реалізація алгоритму гешування на вибір
  Напишіть власну реалізацію алгоритму гешування SHA-1 або SHA-3 (Keccak) на вибір. Зверніть увагу, що ці алгоритми гешування є блочними і вхідні дані слід правильно розділити на порції, кожна довжиною рівно один блок. Якщо останній блок є неповним його треба доповнити згідно зі специфікацією алгоритма.
  Ваша функція повинна мати змогу загешувати будь-які дані довільної довжини. В більш розширеному варіанті можете реалізувати подачу вхідних даних порціями, тобто щоб можна було декілька разів викликати функцію гешування передаючи кожну наступну порцію даних для гешування. Ця функціональність буде доречна для гешування дуже великих обсягів даних, коли неприпустимо зберігати одразу весь аргумент функції в памʼяті.

## 2.2 Тест на співпадіння гешу з бібліотечною реалізацією
  Метою цього етапу є перевірка вашої реалізації на коректність. Для цього оберіть декілька повідомлень різної довжини: до одного блока, більше одного блока, декілька блоків. Далі обчислить геш-значення від цих повідомлень використовуючи вашу реалізацію і використовуючи бібліотечну реалізацію від сторонніх розробників. Результати гешування порівняйте попарно з зробіть висновок щодо коректності обчислень. У разі необхідності знайдіть і виправте помилки у вашій реалізації.


## 2.3 Порівняння швидкодії власної реалізації з бібліотечною
  Метою цього етапу є оптимізація вашої реалізації алгоритму гешування для зменшення обсягу памʼяті і процесорного часу, що використовуються для обчислення геш-значення від повідомлення певної довжини. Для виконання цього етапу зробіть замір часу витраченого на гешування певного повідомлення вашою функцією і замір часу гешування функцією з готової бібліотеки. Результати замірів порівняйте і зробіть висновок щодо ефективності вашої реалізації.
  Обсяг використаної памʼяті можна виміряти додатковими інструментами моніторингу ПЗ або вашої ОС. Усі результати порівняння можна викласти у файлі readme.md вашого репозиторію.

## Запуск Коду
Для запуску цього коду на Python, слід дотримуватися наступних кроків:
1. Встановіть Python на вашому комп'ютері, якщо він ще не встановлений. Можна завантажити Python з [офіційного сайту](https://www.python.org/downloads/).
2. Клонуйте цей репозиторій на свій комп'ютер.
3. Перейдіть до каталогу з кодом.
4. Встановіть залежності, якщо вони є, використовуючи pip.
5. Запустіть код: python my_Algorithm_SHA1.py.

## Приклад Результату
Вихідна програма виведе результати гешованих даних, перевірку з бібліотечним аналогом за часом та значеннями. Наприклад:
```
Custom Hash: 0a0a9f2a6772942557ab5355d76af442f8f65e01
Hashlib Hash: 0a0a9f2a6772942557ab5355d76af442f8f65e01
SHA-1 Hash for message "Hello, World!": MATCHES
Time Custom Hash: 0.0979317999954219
Time Hashlib Hash: 0.0010790000014821999

Custom Hash: b3c16591ae4594a4f409ef2d387d0963c71931c6
Hashlib Hash: b3c16591ae4594a4f409ef2d387d0963c71931c6
SHA-1 Hash for message "Ediko Hlinystyi": MATCHES
Time Custom Hash: 0.09577220000210218
Time Hashlib Hash: 0.0012557000009110197

Custom Hash: 8cb2237d0679ca88db6464eac60da96345513964
Hashlib Hash: 8cb2237d0679ca88db6464eac60da96345513964
SHA-1 Hash for message "12345": MATCHES
Time Custom Hash: 0.11045000000012806
Time Hashlib Hash: 0.0010022000060416758

Custom Hash: d428ebc636c966b187e9945de44c5f8fab961e1f
Hashlib Hash: d428ebc636c966b187e9945de44c5f8fab961e1f
SHA-1 Hash for message "Distributed Lab": MATCHES
Time Custom Hash: 0.09238369999366114
Time Hashlib Hash: 0.0009932999964803457
```
  Отримані геші Custom та Hashlib виявилися ідентичними, що підтверджує правильність реалізації власного алгоритму гешування.
  У результаті порівняння власної реалізації SHA-1 та бібліотечної реалізації hashlib SHA-1, було виявлено, що бібліотечна реалізація працює значно швидше. Ця різниця в швидкості обумовлена оптимізаціями, низькорівневими операціями та використанням мови програмування C у бібліотечній реалізації, що дозволяє їй ефективніше обробляти хеш-функції порівняно з власною реалізацією на мові Python.
